-- ==============================================================================
-- Stitch Calendar - Complete Supabase Setup Script (FIXED ORDER)
-- ==============================================================================
-- 1. TABLE DEFINITIONS (Create first to avoid "relation does not exist" errors)
-- 2. CLEANUP (Drop old policies safely)
-- 3. RLS POLICIES (Re-apply rules)
-- 4. FUNCTIONS & TRIGGERS
-- ==============================================================================

-- ------------------------------------------------------------------------------
-- 1. TABLE DEFINITIONS
-- ------------------------------------------------------------------------------

-- PROFILES (Extends auth.users)
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL PRIMARY KEY,
  email TEXT,
  full_name TEXT CHECK (char_length(full_name) >= 3),
  avatar_url TEXT,
  family_id TEXT, -- Shared identifier for family grouping
  allowed_editors UUID[], -- Array of user_ids who can edit this user's calendar
  theme_settings JSONB DEFAULT '{}'::jsonb, -- Stores user preferences
  updated_at TIMESTAMP WITH TIME ZONE
);

-- EVENT TYPES (Categories)
CREATE TABLE IF NOT EXISTS public.event_types (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL, -- internal name (e.g. 'work')
  label TEXT NOT NULL, -- display name (e.g. 'Trabajo')
  color_class TEXT, -- e.g. 'text-blue-500'
  icon_bg_class TEXT, -- e.g. 'bg-blue-100'
  icon TEXT, -- material symbol name
  is_default BOOLEAN DEFAULT false
);

-- EVENTS (Main Calendar Data)
CREATE TABLE IF NOT EXISTS public.events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  title TEXT NOT NULL,
  start_date TIMESTAMP WITH TIME ZONE NOT NULL,
  end_date TIMESTAMP WITH TIME ZONE,
  all_day BOOLEAN DEFAULT false,
  status TEXT CHECK (status IN ('scheduled', 'completed', 'cancelled', 'overdue')),
  event_type_id BIGINT REFERENCES public.event_types(id) ON DELETE SET NULL, 
  
  -- Extended Details
  location TEXT,
  meeting_url TEXT,
  notes TEXT,
  is_important BOOLEAN DEFAULT false,
  reminder_minutes_before INTEGER,
  
  -- Recurrence
  is_recurring BOOLEAN DEFAULT false,
  recurrence_pattern TEXT CHECK (recurrence_pattern IN ('daily', 'weekly', 'monthly', 'yearly')),

  -- Sharing & Audit
  shared_with TEXT[], 
  created_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL, 
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- NOTIFICATIONS
CREATE TABLE IF NOT EXISTS public.notifications (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  type TEXT NOT NULL CHECK (type IN ('family_request', 'system')),
  from_user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  to_user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'rejected', 'read')),
  payload JSONB, 
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- ------------------------------------------------------------------------------
-- 2. CLEANUP (Safe Reset of Policies)
-- ------------------------------------------------------------------------------
-- Now that tables exist, we can safely drop policies to refresh them
DROP POLICY IF EXISTS "Public profiles are viewable by everyone" ON profiles;
DROP POLICY IF EXISTS "Users can update own profile" ON profiles;
DROP POLICY IF EXISTS "Users can insert own profile" ON profiles;

DROP POLICY IF EXISTS "Users can view own event types" ON event_types;
DROP POLICY IF EXISTS "Users can manage own event types" ON event_types;

DROP POLICY IF EXISTS "Events viewable by authorized users" ON events;
DROP POLICY IF EXISTS "Events insertable by owner or editor" ON events;
DROP POLICY IF EXISTS "Events updatable by owner or editor" ON events;
DROP POLICY IF EXISTS "Events deletable by owner or editor" ON events;

DROP POLICY IF EXISTS "Users can view received notifications" ON notifications;
DROP POLICY IF EXISTS "Users can send notifications" ON notifications;
DROP POLICY IF EXISTS "Users can update received notifications" ON notifications;

-- ------------------------------------------------------------------------------
-- 3. ROW LEVEL SECURITY (RLS) POLICIES
-- ------------------------------------------------------------------------------

-- Enable RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.event_types ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

-- PROFILES POLICIES
CREATE POLICY "Profiles are viewable by authenticated users" ON profiles FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Users can update own profile" ON profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Users can insert own profile" ON profiles FOR INSERT WITH CHECK (auth.uid() = id);

-- EVENT TYPES POLICIES
CREATE POLICY "Users can view all event types" ON event_types FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Users can manage own event types" ON event_types FOR ALL USING (auth.uid() = user_id);

-- EVENTS POLICIES
CREATE POLICY "Events viewable by authorized users" ON events FOR SELECT USING (
  auth.uid() = user_id 
  OR auth.uid()::text = ANY(shared_with) 
  OR ('family' = ANY(shared_with) AND EXISTS ( 
      SELECT 1 FROM profiles 
      WHERE profiles.id = auth.uid() 
      AND profiles.family_id = (SELECT family_id FROM profiles WHERE id = events.user_id)
      AND profiles.family_id IS NOT NULL
  ))
  OR auth.uid() = ANY( 
      SELECT unnest(allowed_editors) FROM profiles WHERE id = events.user_id
  )
);

CREATE POLICY "Events insertable by owner or editor" ON events FOR INSERT WITH CHECK (
  auth.uid() = user_id
  OR auth.uid() = ANY(SELECT unnest(allowed_editors) FROM profiles WHERE id = user_id)
);

CREATE POLICY "Events updatable by owner or editor" ON events FOR UPDATE USING (
  auth.uid() = user_id
  OR auth.uid() = ANY(SELECT unnest(allowed_editors) FROM profiles WHERE id = user_id)
);

CREATE POLICY "Events deletable by owner or editor" ON events FOR DELETE USING (
  auth.uid() = user_id
  OR auth.uid() = ANY(SELECT unnest(allowed_editors) FROM profiles WHERE id = user_id)
);

-- NOTIFICATIONS POLICIES
CREATE POLICY "Users can view received notifications" ON notifications FOR SELECT USING (auth.uid() = to_user_id);
CREATE POLICY "Users can send notifications" ON notifications FOR INSERT WITH CHECK (auth.uid() = from_user_id);
CREATE POLICY "Users can update received notifications" ON notifications FOR UPDATE USING (auth.uid() = to_user_id);

-- ------------------------------------------------------------------------------
-- 4. FUNCTIONS & TRIGGERS (RPC)
-- ------------------------------------------------------------------------------

-- TRIGGER: Auto-create profile on signup
CREATE OR REPLACE FUNCTION public.handle_new_user() 
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, avatar_url)
  VALUES (
    new.id, 
    new.email, 
    new.raw_user_meta_data->>'full_name', 
    new.raw_user_meta_data->>'avatar_url'
  );
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- FUNCTION: Add family member
CREATE OR REPLACE FUNCTION add_family_member(member_email text)
RETURNS jsonb AS $$
DECLARE
  target_id uuid;
  target_family_id text;
  my_family_id text;
BEGIN
  SELECT id, family_id INTO target_id, target_family_id FROM profiles WHERE email = member_email;
  
  IF target_id IS NULL THEN
    RAISE EXCEPTION 'Usuario no encontrado';
  END IF;

  IF target_family_id IS NOT NULL THEN
    SELECT family_id INTO my_family_id FROM profiles WHERE id = auth.uid();
    IF my_family_id = target_family_id THEN
       RAISE EXCEPTION 'El usuario ya est√° en tu familia';
    ELSE
       RAISE EXCEPTION 'Este usuario ya pertenece a otro grupo familiar';
    END IF;
  END IF;

  SELECT family_id INTO my_family_id FROM profiles WHERE id = auth.uid();
  IF my_family_id IS NULL THEN
    my_family_id := 'fam_' || substr(md5(random()::text), 1, 10);
    UPDATE profiles SET family_id = my_family_id WHERE id = auth.uid();
  END IF;

  UPDATE profiles SET family_id = my_family_id WHERE id = target_id;
  RETURN (SELECT to_jsonb(p) FROM profiles p WHERE id = target_id);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- FUNCTION: Respond to request
CREATE OR REPLACE FUNCTION respond_to_family_request(notification_id uuid, accept_request boolean)
RETURNS void AS $$
DECLARE
  notif_record record;
  inviter_family_id text;
BEGIN
  SELECT * INTO notif_record FROM public.notifications WHERE id = notification_id;
  
  IF notif_record.to_user_id != auth.uid() THEN
    RAISE EXCEPTION 'No autorizado';
  END IF;
  
  UPDATE public.notifications SET status = CASE WHEN accept_request THEN 'accepted' ELSE 'rejected' END
  WHERE id = notification_id;
  
  IF accept_request THEN
    SELECT family_id INTO inviter_family_id FROM profiles WHERE id = notif_record.from_user_id;
    
    IF inviter_family_id IS NULL THEN
       inviter_family_id := 'fam_' || substr(md5(random()::text), 1, 10);
       UPDATE profiles SET family_id = inviter_family_id WHERE id = notif_record.from_user_id;
    END IF;
    
    UPDATE profiles SET family_id = inviter_family_id WHERE id = auth.uid();
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- FUNCTION: Remove family member
CREATE OR REPLACE FUNCTION remove_family_member(target_user_id uuid)
RETURNS void AS $$
DECLARE
  my_family_id text;
  target_family_id text;
BEGIN
  SELECT family_id INTO my_family_id FROM profiles WHERE id = auth.uid();
  SELECT family_id INTO target_family_id FROM profiles WHERE id = target_user_id;
  
  IF my_family_id IS DISTINCT FROM target_family_id THEN
    RAISE EXCEPTION 'Este usuario no pertenece a tu grupo familiar';
  END IF;
  
  UPDATE profiles SET family_id = null WHERE id = target_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
