-- Supabase Schema Plan for Stitch Calendar
-- This file documents the required Database Schema, RLS Policies, and RPC Functions
-- to support the current frontend logic (mocked in dataService.js).

-- 1. Tables

-- Profiles (Users)
create table public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  email text,
  full_name text,
  avatar_url text,
  family_id text, -- Shared identifier for family grouping
  allowed_editors uuid[], -- Array of user_ids who can edit this user's calendar
  theme_settings jsonb default '{}'::jsonb, -- Stores user preferences: theme, colorTheme, customColor, etc.
  updated_at timestamp with time zone,
  
  constraint username_length check (char_length(full_name) >= 3)
);

-- Events
create table public.events (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  title text not null,
  start_date timestamp with time zone not null,
  end_date timestamp with time zone,
  all_day boolean default false,
  status text check (status in ('scheduled', 'completed', 'cancelled', 'overdue')),
  event_type_id bigint references public.event_types(id) on delete set null, -- FK to Event Types
  
  -- Extended Details
  location text,
  meeting_url text,
  notes text,
  is_important boolean default false,
  reminder_minutes_before integer, -- For event notifications (e.g., 15 mins before)
  
  -- Recurrence
  is_recurring boolean default false,
  recurrence_pattern text check (recurrence_pattern in ('daily', 'weekly', 'monthly', 'yearly')),

  -- Sharing & Audit
  shared_with text[], -- Array of user_ids or 'family' keyword
  created_by uuid references public.profiles(id), -- Audit trail
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Event Types
create table public.event_types (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  name text not null, -- internal name (e.g. 'work')
  label text not null, -- display name (e.g. 'Trabajo')
  color_class text, -- e.g. 'text-blue-500'
  icon_bg_class text, -- e.g. 'bg-blue-100'
  icon text, -- material symbol name
  is_default boolean default false
);

-- Notifications
create table public.notifications (
  id uuid default gen_random_uuid() primary key,
  type text not null check (type in ('family_request', 'system')),
  from_user_id uuid references public.profiles(id) on delete cascade,
  to_user_id uuid references public.profiles(id) on delete cascade not null,
  status text default 'pending' check (status in ('pending', 'accepted', 'rejected', 'read')),
  payload jsonb, -- Flexible data (e.g. family_id snapshot)
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 2. Row Level Security (RLS) Policies

-- Profiles
-- Read: Everyone can read basic profile info (needed for sharing UI)
create policy "Public profiles are viewable by everyone" on profiles for select using (true);
-- Update: Users can only update their own profile
create policy "Users can update own profile" on profiles for update using (auth.uid() = id);

-- Events
-- Read: Owner OR Shared With OR Family Member OR Editor
create policy "Events viewable by authorized users" on events for select using (
  auth.uid() = user_id -- Owner
  or auth.uid() = any(shared_with) -- Direct Share
  or ('family' = any(shared_with) and exists ( -- Family Share
      select 1 from profiles 
      where profiles.id = auth.uid() 
      and profiles.family_id = (select family_id from profiles where id = events.user_id)
  ))
  or auth.uid() = any( -- Editor Access
      select unnest(allowed_editors) from profiles where id = events.user_id
  )
);

-- Insert: Owner OR Editor
create policy "Events insertable by owner or editor" on events for insert with check (
  auth.uid() = user_id
  or auth.uid() = any(
      select unnest(allowed_editors) from profiles where id = user_id
  )
);

-- Update: Owner OR Editor
create policy "Events updatable by owner or editor" on events for update using (
  auth.uid() = user_id
  or auth.uid() = any(
      select unnest(allowed_editors) from profiles where id = user_id
  )
);

-- Notifications
-- Read: Users can see notifications sent TO them
create policy "Users can see their notifications" on notifications for select using (auth.uid() = to_user_id);
-- Insert: Users can create notifications (requests)
create policy "Users can send notifications" on notifications for insert with check (auth.uid() = from_user_id);
-- Update: Users can update status of their notifications
create policy "Users can update their notifications" on notifications for update using (auth.uid() = to_user_id);

-- 3. RPC Functions (Security Definer)
-- These functions bypass RLS to perform cross-user operations safely

-- add_family_member (Owner adds Member)
-- Logic: Check if Caller is in a family. Update Target's family_id to match Caller.
create or replace function add_family_member(target_email text)
returns json
language plpgsql
security definer
as $$
declare
  target_user_id uuid;
  my_family_id text;
begin
  -- Get Target ID
  select id into target_user_id from profiles where email = target_email;
  if target_user_id is null then raise exception 'User not found'; end if;
  
  -- Get My Family ID
  select family_id into my_family_id from profiles where id = auth.uid();
  if my_family_id is null then 
     my_family_id := 'family_' || auth.uid(); -- Generate new if none
     update profiles set family_id = my_family_id where id = auth.uid();
  end if;
  
  -- Update Target
  update profiles set family_id = my_family_id where id = target_user_id;
  
  return json_build_object('success', true);
end;
$$;

-- respond_to_family_request (Target accepts Request from Requester)
-- Logic: Check Notification. Update Requester's family_id to match Target (Approver).
create or replace function respond_to_family_request(notification_id uuid, accept boolean)
returns json
language plpgsql
security definer
as $$
declare
  notif record;
  approver_family_id text;
begin
  -- Get Notification and Verify Ownership
  select * into notif from notifications where id = notification_id;
  
  if notif.to_user_id != auth.uid() then
    raise exception 'Unauthorized';
  end if;
  
  if accept then
    -- Get Approver's Family ID
    select family_id into approver_family_id from profiles where id = auth.uid();
    
    if approver_family_id is null then
       raise exception 'You do not have a family group';
    end if;
    
    -- Update Requester (from_user_id) to join Approver's family
    update profiles set family_id = approver_family_id where id = notif.from_user_id;
    
    update notifications set status = 'accepted' where id = notification_id;
  else
    update notifications set status = 'rejected' where id = notification_id;
  end if;
  
  return json_build_object('success', true);
end;
$$;

-- remove_family_member (Owner/Admin removes Member)
create or replace function remove_family_member(target_user_id uuid)
returns json
language plpgsql
security definer
as $$
declare
  my_family_id text;
  target_family_id text;
begin
  -- Get My Family ID
  select family_id into my_family_id from profiles where id = auth.uid();
  
  -- Get Target Family ID
  select family_id into target_family_id from profiles where id = target_user_id;
  
  if my_family_id is null or target_family_id is null or my_family_id != target_family_id then
    raise exception 'User not in your family';
  end if;
  
  -- Remove from family
  update profiles set family_id = null where id = target_user_id;
  
  return json_build_object('success', true);
end;
$$;
